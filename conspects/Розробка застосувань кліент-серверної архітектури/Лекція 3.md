## Що таке «`Багатопоточність`»?

`Багатопоточність` – це спеціалізована форма багатозадачності (multitasking). Що стосується багатозадачності, то виділяють два типи багатозадачності: 

-   засновану на процесах (process-based);
-   засновану на потоках (thread-based).

По суті, `процес` (`process`) – це програма, що окремо виконується. Таким чином, заснована на процесах багатозадачність – засіб, що дозволяє вашому комп'ютеру виконувати кілька програм одночасно.

Відмінності заснованої нa процесах і багатопoтoчнoї багатозaдaчнoсті мoжна сфoрмулювaти наступним чином: перша підтримує одночасне виконання декількох прoгрaм, a друга має справу з одночасним викoнанням різних фрагментів однієї прoгрaми.

За допомогою процесів можна організувати паралельне виконання програм. Для цього процеси клонуються за допомогою викликів функції fork() або функції exec(), а потім між ними (процесами) організується взаємодія засобами IPC. Це досить дорогий з погляду ресурсів процес.

З іншого боку, для організації паралельного виконання та взаємодії частини програми можна використовувати механізм багатопоточності. Основною одиницею є потік. Розглянемо цей механізм докладніше.

## Визначте термін «`Потоки`».

Послідовна реалізація сервера, про яку йшлося у попередніх практичних роботах, може виявитися невідповідною, оскільки клієнти будуть змушені чекати на завершення обробки всіх попередніх запитів на встановлення з'єднання. Якщо клієнт вирішить передати великі обсяги даних (наприклад, кілька мегабайт), послідовний сервер відкладе обслуговування всіх інших клієнтів, поки не виконає цей запит.

Паралельна реалізація сервера дає можливість обійтися без тривалих затримок, оскільки не дозволяє одному клієнту захопити всі ресурси. Натомість паралельний сервер підтримує обмін даними відразу з кількома клієнтами для того, щоб їх запити оброблялися одночасно. Тому, з погляду клієнта, паралельний сервер забезпечує кращий час відгуку, що спостерігається в порівнянні з послідовним сервером.

Розпаралелювання обробки на сервері досягається створенням окремого потоку для обробки запитів одного клієнта або окремого однопотокового процесу обробки запитів одного клієнта.

`Потік` (`thread`) - це керована одиниця виконуваного коду. У всіх процесів обов'язково є один потік, але їх може бути і більше. Це означає, що в одній програмі можуть виконуватися кілька завдань одночасно. Прикладом може служити текстовий редактор, в якому можливі одночасні форматування тексту і друк, що здійснюються в окремих потоках.

## Перелічіть переваги та недоліки багатопотокових процесів.

Багатопотокові процеси мають дві основні переваги в порівнянні з однопотоковими процесами: більш висока ефективність і розподілена пам'ять. Підвищення ефективності пов'язані зі зменшенням витрат за переключення контексту. Перемикачем контексту називаються дії, що виконуються операційною системою при передачі ресурсів процесора від потоку виконання до іншого. При перемиканні з одного потоку на інший операційна система повинна зберегти в пам'яті стан попереднього потоку (наприклад, значення регістрів) та відновити стан наступного потоку. Потоки в тому самому процесі поділяють значну частину інформації про стан процесу, тому операційній системі доводиться виконувати менший обсяг роботи зі збереження та відновлення стану. Внаслідок цього перемикання з одного потоку на інший в тому самому процесі відбувається швидше в порівнянні з перемиканням між двома потоками в різних процесах. Зокрема, оскільки потоки того самого процесу поділяють адресний простір пам'яті, то перемикання між потоками процесу означає, що операційна система не повинна змінювати відображення віртуальної пам'яті на фізичну.

Друга перевага потоків, тобто. пам'ять, що розділяється, ймовірно, є для програмістів ще важливішим, ніж підвищення ефективності. Потоки спрощують розробку паралельних серверів, у яких всі копії сервера повинні взаємодіяти один з одним або звертатися до елементів даних, що розділяються. Крім того, потоки спрощують розробку систем контролю та управління. Зокрема, оскільки ведені потоки в сервері спільно використовують пам'ять, вони можуть записувати в глобальну пам'ять статистичну інформацію, що дозволяє контролюючому потоку формувати звіти про активність ведених потоків сервера для системного адміністратора.

Хоча потоки мають переваги над однопотоковими процесами, де вони позбавлені також певних недоліків. Один з найбільш важливих недоліків пов'язаний з тим, що потоки не тільки поділяють пам'ять, але й мають загальний стан процесу, тому дії, виконані одним потоком, можуть вплинути на інші потоки того самого процесу. Наприклад, якщо два потоки спробують одночасно звернутися до однієї і тієї ж змінної, вони можуть стати на заваді один одному.

API-інтерфейс потоків надає функції, які можуть використовуватись потоками для координації роботи. Однак багато бібліотечних функцій, що повертають покажчики на статичні елементи даних, не є безпечними з точки зору потоків, а це означає, що результати виклику таких функцій можуть виявитися непередбачуваними.

Ще один недолік потоків (і відмінність однопотокового процесора від багатопотокового) пов'язаний із відсутністю надійності. Якщо одна з паралельно працюючих копій однопотокового сервера викликає серйозну помилку (наприклад, у ній буде виконано посилання на неприпустиму область пам'яті), то операційна система завершить лише той процес, який викликав помилку. З іншого боку, якщо серйозна помилка буде викликана одним із потоків багатопотокового сервера, то операційна система завершить весь процес.

## Вкажіть кроки алгоритму роботи паралельного (багатопоточного)сервера із встановленням логічного з'єднання.

Наведемо узагальнений алгоритм роботи паралельного сервера із встановленням логічного з'єднання:

1. Провідний потік. Створити сокет і виконати його прив'язку до локальної адреси. Залишити сокет непідключеним.
2. Провідний потік. Перевести сокет до пасивного режиму, підготувавши його для використання сервером.
3. Провідний потік. Викликати в циклі функцію accept для отримання чергового запиту від клієнта та створювати новий потік чи процес для формування відповіді.
4. Ведений потік. Робота потоку починається з отримання доступу до з'єднання, отриманого від провідного потоку (тобто сокету з'єднання).
5. Ведений потік. Здійснювати обмін даними з клієнтом через з'єднання: приймати запит (запити) та передавати відповідь (відповіді).
6. Ведений потік. Закрити з'єднання та завершити роботу. Ведений потік завершує роботу після обробки всіх запитів від одного клієнта.

Сервер функціонує невизначено довгий час, очікуючи на надходження нових запитів на встановлення з'єднання від клієнтів. Його провідний потік при підключенні клієнта створює новий потік для обробки запитів кожного нового з'єднання і надає кожному веденому потоку можливість взяти на себе весь обмін даними з клієнтом.

## Яке призначення функції CreateThread()?

Функція `CreateThread`() створює потік, який виконується в межах адресного простору виклику процесу

## Поясніть значення кожного параметру функції CreateThread().

HANDLE `CreateThread` (
	LPSECURITY_ATTRIBUTES lpThreadAttributes // покажчик на атрибути безпеки
	DWORD dwStackSize // розмір стека початкового потоку
	LPTHREAD_START_ROUTINE lpStartAddress // Покажчик на функцію потоку
	LPVOID lpParameter // аргумент для нового потоку
	DWORD dwCreationFlags, // створення прапорів
	LPDWORD lpThreadId // покажчик на ID потік для отримання
);

`lpThreadAttributes` – це покажчик на структуру `SECURITY_ATTRIBUTES`, який визначає, чи може дескриптор потоку бути успадкований дочірніми процесами. Якщо `lpThreadAttributes` набуває значення `NULL`, дескриптор потоку не може бути успадкований.

Член структури `lpSecurityDescriptor` визначає дескриптор безпеки нового потоку. Якщо `lpThreadAttributes` набуває значення `NULL`, то потік отримує дескриптор безпеки за промовчанням.

`dwStackSize` - ця величина визначає початковий розмір стека в байтах. Система заокруглює це значення до найближчої сторінки. Якщо це значення дорівнює нулю або менше розміру стека за замовчуванням, то використовується той самий розмір, що й виклик потоку. Стек звільнено у разі, коли потік завершується.

`lpStartAddress` – покажчик на певну прикладну функцію типу `LPTHREAD_START_ROUTINE` для виконання її потоком та подання початкової адреси потоку.

`lpParameter` - визначає єдину 32-бітову величину параметра, передану в потік.

`wCreationFlags` – використовується визначення додаткових прапорів, які керують створенням потоку. Якщо прапор `CREATE_SUSPENDED` визначено, потік створений у зупиненому стані і не працюватиме, доки функція `ResumeThread`() не буде викликана. Якщо ця нульова величина, то потік виконується негайно після створення. Водночас жодних інших величин не передбачено.

`lpThreadId` – покажчик на 32-бітову змінну, яка отримує ідентифікатор потоку.

Якщо цей параметр набуває значення `NULL`, то ідентифікатор потоку не повертається.